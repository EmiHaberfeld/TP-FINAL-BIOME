---
title: "Trabajo Práctico Final  \nBiometría II - 2021"
author: "Matías Alemán, Milagros Azcueta, Manuel Fiz, Emilia Haberfeld, Diego Kafer, Ilan Shalom"
date: "21/10/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


# Introducción
Breve y con el único fin de dar el contexto necesario para entender el análisis) y objetivos

# Materiales y métodos
Mencionar, además del diseño experimental o de campo, el o los modelos estadísticos propuestos y la estrategia analítica.

# Resultados
Presentar gráficos y/o Tablas. Editar lo que sea necesario de formato para que el lector comprenda. Informar medias, magnitud del efecto, letras de significación cuando corresponda. Supuestos: salvo excepciones, sólo mencionarlos y mencionar su cumplimiento. Incluir decisiones metodológicas.

# Discusión o conclusión
Párrafo de discusión/conclusión.

# Bibliografía
Si corresponde

```{r}
rm(list = ls()) 

################## CARGA DE LIBRERIAS Y DATOS:
library(reshape2)  #melt
library(pastecs)   #tapply
library(ggplot2)
library(ggeffects) #ggpredict
library(plyr)      #revalue
library(readxl)    #excel
library(nlme)      #gls
library(lmerTest)  #ranova
library(dplyr)
library(geepack)   #geeglm
library(emmeans)   #comparaciones
#install.packages("glmmTMB")
library(glmmTMB)
library(lme4)
#install.packages("car")
library(car)       #Anova
library(MuMIn)     #model.sel

setwd("D:/Milagros Azcueta/Documents/GitHub/TP-FINAL-BIOME")
datos <- read_excel("datos.xlsx")
str(datos)
datos$Semana         <- as.factor(datos$Semana)
datos$ID             <- as.factor(datos$ID)
datos$ANT            <- as.factor(datos$ANT)
datos$PROB           <- as.factor(datos$PROB)
datos$TRATAMIENTO    <- as.factor(datos$TRATAMIENTO)
str(datos)
# Colmena no la vamos a incluir en el analisis porque esta explicada por Semana.

################################################################################################
############################### DESCRIPTIVA ####################################################
################################################################################################

################## TESTEO:
# PASAMOS DATOS TEST A LONG:
wide_test <- datos[,c(1,2,3,4,5,10,11,12)]
long_test <- melt(wide_test,
                  id.vars = c("Semana", "ID", "ANT", "PROB", "TRATAMIENTO"),
                  variable.name = "tiempo_test",
                  value.name = "rta")

# PROBABILIDAD DE EXITO SEGUN TRATAMIENTO Y TIEMPO:
prob_exito <- round(tapply(long_test$rta,list(long_test$TRATAMIENTO,long_test$tiempo_test),
                           mean),2)
prob_exito
# Creamos un data frame con estos valores:
prob_exito_long <- as.data.frame.table(prob_exito)
colnames(prob_exito_long) <- c("Tratamiento","Tiempo_de_testeo","Proporcion_de_exitos")
# Graficamente:
gp_test <- ggplot(prob_exito_long, aes(x=Tiempo_de_testeo, y=Proporcion_de_exitos, 
                                       colour=Tratamiento, group=Tratamiento)) +
  geom_line(aes(linetype=Tratamiento), size=.6) +
  geom_point(aes(shape=Tratamiento),size=3) +
  labs(x="Tiempo de testeo",y="Proporcion de exitos",
       title="Proporcion de exitos en funcion del tiempo y el tratamiento") +
  ylim(0,1) + theme_bw()
gp_test

################## ENTRENAMIENTO:
# PASAMOS DATOS ENTRENAMIENTO A LONG:
wide_tr <- datos[,c(1,2,3,4,5,6,7,8,9)]
long_tr <- melt(wide_tr,
                id.vars = c("Semana", "ID", "ANT", "PROB", "TRATAMIENTO"),
                variable.name = "tiempo_tr",
                value.name = "rta")

# PROBABILIDAD DE EXITO SEGUN TRATAMIENTO Y TIEMPO:
prob_exito_tr <- round(tapply(long_tr$rta,list(long_tr$TRATAMIENTO,long_tr$tiempo_tr),mean),2)
prob_exito_tr
# Creamos un data frame con estos valores:
prob_exito_long_tr <- as.data.frame.table(prob_exito_tr)
colnames(prob_exito_long_tr) <- c("Tratamiento","Nro_de_ensayo","Proporcion_de_exitos")

# Graficamente:
gp_tr <- ggplot(prob_exito_long_tr, aes(x=Nro_de_ensayo, y=Proporcion_de_exitos, 
                                        colour=Tratamiento, group=Tratamiento)) +
  geom_line(aes(linetype=Tratamiento), size=.6) +
  geom_point(aes(shape=Tratamiento),size=3) +
  labs(x="Numero de ensayo",y="Proporcion de exitos",title="Curva de aprendizaje") +
  ylim(0,1) + theme_bw()
gp_tr

################## SIGNIFICANCIA DE SEMANA COMO COVARIABLE:
prob_exito_week <- round(tapply(long_test$rta,list(long_test$Semana,long_test$tiempo_test),
                                mean),2)
prob_exito_week
# Creamos un data frame con estos valores:
prob_exito_w_df <- as.data.frame.table(prob_exito_week)
colnames(prob_exito_w_df) <- c("Semana","Nro_de_ensayo","Proporcion_de_exitos")

# Graficamente:
gp_week <- ggplot(prob_exito_w_df, aes(x=Nro_de_ensayo, y=Proporcion_de_exitos, colour=Semana, 
                                       group=Semana)) +
  geom_line(aes(linetype=Semana), size=.6) +
  geom_point(aes(shape=Semana),size=3) +
  labs(x="Numero de ensayo",y="Proporcion de exitos",title="Promedio de rta por semana") +
  ylim(0,1) + theme_bw()
gp_week

## Las semanas 5 y 7 parecen ser outliers. Podria excluirlas:
######## LO DEJO COMENTADO PERO LA IDEA ES NO SACAR LOS DATOS.
# Primero ordeno el df por semana para ver que filas quiero sacar. Despues las borro.
long_test_order <- arrange(long_test,Semana)
#long_test_2     <- long_test_order[-c(198:264,349:396),]
#long_test_2$TRATAMIENTO <- as.factor(long_test_2$TRATAMIENTO)
# Genero el modelo nulo, Semana es la unica explicatoria:
m0 <- gls(rta ~ Semana, correlation=corCAR1(form=~1|ID), data=long_test)
anova(m0)

################################################################################################
############################### MODELADO #######################################################
################################################################################################

################## PRIMERA PROPUESTA: GEEGLM
# Para geeglm, las filas del df tienen que estar ordenadas por paciente y por tiempo:
long_test <- arrange(long_test,ID)   #si uso todas las semanas

# Notacion de matrices de covarianza en geeglm:
## Estructura simple: independence
## Simetria compuesta: exchangeable
## AR1: ar1
## Desestructurada: unstructured

## PRIMERA PROPUESTA: triple interaccion
m1 <- geeglm(formula=rta~ANT*PROB*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="unstructured")
anova(m1)
m2 <- geeglm(formula=rta~ANT*PROB*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="independence")
anova(m2)
m3 <- geeglm(formula=rta~ANT*PROB*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="exchangeable")
anova(m3)
m4 <- geeglm(formula=rta~ANT*PROB*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="ar1")
anova(m4)

## SEGUNDA PROPUESTA: tratamiento*tiempo
m5 <- geeglm(formula=rta~TRATAMIENTO*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="unstructured")
anova(m5)
m6 <- geeglm(formula=rta~TRATAMIENTO*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="independence")
anova(m6)
m7 <- geeglm(formula=rta~TRATAMIENTO*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="exchangeable")
anova(m7)
m8 <- geeglm(formula=rta~TRATAMIENTO*tiempo_test+Semana,family=binomial,data=long_test,id=ID,
             corstr="ar1")
anova(m8)

## SELECCION DE MODELOS (en geeglm rankeamos por QIC):
model.sel(m1,m2,m3,m4,m5,m6,m7,m8, rank = QIC)

## Si elejimos simetria compuesta (m3 o m7), decimos que para cada abeja hay una misma
## correlacion entre tiempos.
## Independiente: la sacamos porque no estariamos declarando dependencia de datos entre
## tiempos para una misma abeja
## AR1: la sacamos porque tiene un menor QIC, tiempos no equidistantes + tiene mismo N
## parametros que la de simetria compuesta y a pesar de eso tiene QIC mayor.
## Desestructurada: la sacamos porque estima mas parametros, por eso el QIC da un poco
## mas alto.

# Como elejimos simetria compuesta, probamos un condicional:
################## SEGUNDA PROPUESTA: GLMMTMB
# glmmTMB es bueno para mixtos y muchos niveles del aleatorio.
m9 <- glmmTMB(rta ~ TRATAMIENTO*tiempo_test + Semana + (1|ID), data=long_test, family="binomial")

################################################################################################
################################## SUPUESTOS ###################################################
################################################################################################

# Parte fija:
library(DHARMa)
sim <- simulateResiduals(m9, n=1000)
plot(sim)
# Parte aleatoria:
e_aleat <- ranef(m9)
e_aleat <- as.data.frame(e_aleat)
e_aleat <- e_aleat[4:5]
colnames(e_aleat) <- c("ID","alfa")
## Grafico un qqPlot con estos residuos:
qqPlot(e_aleat$alfa,main="QQ Plot residuos VE aleatoria")
## Hago la prueba de shapiro:
shapiro.test(e_aleat$alfa)

################## NO HAY EVIDENCIAS PARA RECHAZAR SUPUESTOS DE LA PARTE FIJA NI ALEATORIA.

################################################################################################
############################### COMPARACIONES ##################################################
################################################################################################

# Corremos el anova:
Anova(m9,test.statistic="Chisq")  # Semana e interaccion significativas
# Seteamos el emmeans:
options(emmeans= list(emmeans = list(infer = c(TRUE, TRUE)),
                      contrast = list(infer = c(TRUE, TRUE))))

################## PRIMERA PROPUESTA: COMO TENEMOS COMPARACIONES A PRIORI, HACEMOS BONFERRONI
################## BONFERRONI SE PUEDE PONER EN EL EMMEANS. 
################## A CONTINUACION, PROBAMOS MUUUCHAS FORMAS DE QUE SALGA. 
################## Las dejamos comentadas, la que funciono (pero no sabemos si esta bien
################## porque da todo NS) se llama "FUNCIONA" y esta al final.
# -------------------------------------------------------------------------------------------- #
#comp <- emmeans(m9, 
#                pairwise ~ TRATAMIENTO*tiempo_test, type="response",adjust="bonferroni", 
#                contrast=list(c(1,0,0,-1,0,0,0,0,0,0,0,0), 
#                              c(0,1,-1,0,0,0,0,0,0,0,0,0), 
#                               c(0,0,0,0,1,0,0,-1,0,0,0,0),
#                               c(0,0,0,0,0,0,0,0,1,0,0,-1),
#                               c(0,0,0,0,0,0,0,0,0,1,-1,0)))
# comp2 <- emmeans(m9, specs=c("TRATAMIENTO","tiempo_test"),type="response",adjust="bonferroni", 
#                 contrast=list(c(1,0,0,-1,0,0,0,0,0,0,0,0), 
#                               c(0,1,-1,0,0,0,0,0,0,0,0,0), 
#                               c(0,0,0,0,1,0,0,-1,0,0,0,0),
#                               c(0,0,0,0,0,0,0,0,1,0,0,-1),
#                               c(0,0,0,0,0,0,0,0,0,1,-1,0)))
# comp3 <- emmeans(m9,type="response", specs=c("TRATAMIENTO","tiempo_test"),adjust="bonferroni", 
#                  contrast=list(c(1,0,0,-1,0,0,0,0,0,0,0,0), 
#                                c(0,1,-1,0,0,0,0,0,0,0,0,0)))
# comp4 <- rbind(emmeans(m9, specs= pairwise~TRATAMIENTO|tiempo_test,type="response",adjust="bonferroni", 
#                  contrast=list(c(1,0,0,-1,0,0,0,0,0,0,0,0), 
#                                c(0,1,-1,0,0,0,0,0,0,0,0,0), 
#                                c(0,0,0,0,1,0,0,-1,0,0,0,0),
#                                c(0,0,0,0,0,0,0,0,1,0,0,-1),
#                                c(0,0,0,0,0,0,0,0,0,1,-1,0))))
# comp5 <- emmeans(m9, specs= pairwise~TRATAMIENTO|tiempo_test,type="response",adjust="bonferroni",
#                  contrast=list (c("contraste_pos","constante_alto"),c("contraste_neg","constante_bajo")))
# # Probamos con la funcion contrast de emmeans, pero no anda con glmmTMB:
# contrast(m9, method=list(c(1,0,0,-1,0,0,0,0,0,0,0,0), 
#                          c(0,1,-1,0,0,0,0,0,0,0,0,0), 
#                          c(0,0,0,0,1,0,0,-1,0,0,0,0), 
#                          c(0,0,0,0,0,1,-1,0,0,0,0,0), 
#                          c(0,0,0,0,0,0,0,0,1,0,0,-1), 
#                          c(0,0,0,0,0,0,0,0,0,1,-1,0)),
#          specs=c("TRATAMIENTO","tiempo_test"),
#          adjust = "bonferroni")
# -------------------------------------------------------------------------------------------- #
FUNCIONA<-contrast(emmeans(m9,~TRATAMIENTO*tiempo_test),type="response",
                list("3hs_alto_pos"=c(1,0,0,-1,0,0,0,0,0,0,0,0), 
                     "3hs_bajo_neg"=c(0,1,-1,0,0,0,0,0,0,0,0,0), 
                     "24hs_alto_pos"=c(0,0,0,0,1,0,0,-1,0,0,0,0), 
                     "24hs_bajo_neg"=c(0,0,0,0,0,1,-1,0,0,0,0,0), 
                     "48hs_alto_pos"=c(0,0,0,0,0,0,0,0,1,0,0,-1), 
                     "48hs_bajo_neg"=c(0,0,0,0,0,0,0,0,0,1,-1,0)),
                adjust="bonferroni")
FUNCIONA
plot(FUNCIONA,comparisons=T)  ## Funciona... Mas o menos. Hay que verlo en el TP!

```

