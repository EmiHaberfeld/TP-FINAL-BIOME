---
title: "Trabajo Pr치ctico Final  \nBiometr칤a II - 2021"
author: "Mat칤as Alem치n, Milagros Azcueta, Manuel Fiz, Emilia Haberfeld, Diego Kafer, Ilan Shalom"
date: "21/10/2021"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


# Introducci칩n
Breve y con el 칰nico fin de dar el contexto necesario para entender el an치lisis) y objetivos

# Materiales y m칠todos
Mencionar, adem치s del dise침o experimental o de campo, el o los modelos estad칤sticos propuestos y la estrategia anal칤tica.

# Resultados
Presentar gr치ficos y/o Tablas. Editar lo que sea necesario de formato para que el lector comprenda. Informar medias, magnitud del efecto, letras de significaci칩n cuando corresponda. Supuestos: salvo excepciones, s칩lo mencionarlos y mencionar su cumplimiento. Incluir decisiones metodol칩gicas.

# Discusi칩n o conclusi칩n
P치rrafo de discusi칩n/conclusi칩n.

# Bibliograf칤a
Si corresponde

```{r}
#################################### SCRIPT ####################################

# Borrar objetos de la memoria
rm(list = ls()) 

################################################################################
####################### CARGA DE LIBRERIAS Y DATOS: ############################
################################################################################

library(reshape2)  #melt
library(pastecs)   #tapply
library(ggplot2)
library(ggeffects) #ggpredict
library(plyr)      #revalue
library(readxl)    #excel
library(nlme)      #gls
library(lmerTest)  #ranova
library(dplyr)
library(geepack)   #geeglm
library(emmeans)   #comparaciones
#install.packages("glmmTMB")
library(glmmTMB)
library(lme4)
#install.packages("car")
library(car)       #Anova
library(MuMIn)     #model.sel
library(dplyr)

setwd("D:/Milagros Azcueta/Documents/GitHub/TP-FINAL-BIOME")
setwd("C:/Users/hecto/Desktop/Il烱/Biome II/TP FINAL/TP-FINAL-BIOME")
datos <- read_excel("datos.xlsx")
str(datos)
datos$SEMANA         <- as.factor(datos$SEMANA)
datos$ID             <- as.factor(datos$ID)
datos$ANT            <- as.factor(datos$ANT)
datos$PROB           <- as.factor(datos$PROB)
datos$TRATAMIENTO    <- as.factor(datos$TRATAMIENTO)
str(datos)
# Colmena no la vamos a incluir en el analisis porque esta explicada por Semana.

################################################################################
############################### DESCRIPTIVA ####################################
################################################################################

################## ENTRENAMIENTO:

# PASAMOS DATOS ENTRENAMIENTO A LONG:
wide_entr <- datos[,c(1,2,3,4,5,6,7,8,9)]
long_entr <- melt(wide_entr,
                id.vars = c("SEMANA", "ID", "ANT", "PROB", "TRATAMIENTO"),
                variable.name = "tiempo_entr",
                value.name = "rta")

# PROBABILIDAD DE EXITO SEGUN TRATAMIENTO Y TIEMPO:
prob_exito_entr <- round(tapply(long_entr$rta,list(long_entr$TRATAMIENTO,long_entr$tiempo_entr),mean),2)
prob_exito_entr
# Creamos un data frame en formato long con estos valores:
prob_exito_entr_long <- as.data.frame.table(prob_exito_entr)
colnames(prob_exito_entr_long) <- c("TRATAMIENTO","nro_ensayo","proporcion_exitos")

# Graficamente:
gp_entr <- ggplot(prob_exito_entr_long, aes(x=nro_ensayo, y=proporcion_exitos, 
                                        colour=TRATAMIENTO, group=TRATAMIENTO)) +
  geom_line(aes(linetype=TRATAMIENTO), size=.6) +
  geom_point(aes(shape=TRATAMIENTO),size=3) +
  labs(x="N칰mero de ensayo",y="Proporci칩n de 칠xitos",title="Curva de aprendizaje") +
  ylim(0,1) + theme_bw()
gp_entr


################## TESTEO:

# PASAMOS DATOS TEST A LONG:
wide_testeo <- datos[,c(1,2,3,4,5,10,11,12)]
long_testeo <- melt(wide_testeo,
                  id.vars = c("SEMANA", "ID", "ANT", "PROB", "TRATAMIENTO"),
                  variable.name = "tiempo_testeo",
                  value.name = "rta")

# PROBABILIDAD DE EXITO SEGUN TRATAMIENTO Y TIEMPO EN TESTEO:
prob_exito_testeo <- round(tapply(long_testeo$rta,list(long_testeo$TRATAMIENTO,long_testeo$tiempo_testeo), mean),2)
prob_exito_testeo
# Creamos un data frame en formato long con estos valores:
prob_exito_testeo_long <- as.data.frame.table(prob_exito_testeo)
colnames(prob_exito_testeo_long) <- c("TRATAMIENTO","tiempo_testeo","proporcion_exitos")
# Graficamente:
gp_testeo <- ggplot(prob_exito_testeo_long, aes(x=tiempo_testeo, y=proporcion_exitos,
                                              colour=TRATAMIENTO, group=TRATAMIENTO)) + 
  geom_line(aes(linetype=TRATAMIENTO), size=.6) +
  geom_point(aes(shape=TRATAMIENTO),size=3) +
  labs(x="Tiempo de testeo",y="Proporcion de exitos",
       title="Proporcion de 칠xitos en funci칩n del tiempo y el tratamiento") +
  ylim(0,1) + theme_bw()
gp_testeo


################## SEMANA COMO COVARIABLE:

prob_exito_semana <- round(tapply(long_testeo$rta,list(long_testeo$SEMANA,long_testeo$tiempo_testeo), mean),2)
prob_exito_semana
# Creamos un data frame en formato long con estos valores:
prob_exito_semana_long <- as.data.frame.table(prob_exito_semana)
colnames(prob_exito_semana_long) <- c("SEMANA","tiempo_testeo","proporcion_exitos")

# Graficamente:
gp_semana <- ggplot(prob_exito_semana_long, aes(x=tiempo_testeo, y=proporcion_exitos, colour=SEMANA,group=SEMANA)) +
  geom_line(aes(linetype=SEMANA), size=.6) +
  geom_point(aes(shape=SEMANA),size=3) +
  labs(x="Tiempo de testeo",y="Proporci칩n de 칠xitos",title="Proporcion de 칠xitos en funci칩n del tiempo y la semana") +
  ylim(0,1) + theme_bw()
gp_semana

## Las semanas 5 y 7 parecen ser outliers. Podria excluirlas:
######## LO DEJO COMENTADO PERO LA IDEA ES NO SACAR LOS DATOS.
# Primero ordeno el df por semana para ver que filas quiero sacar. Despues las borro.
#long_test_order <- arrange(long_test,Semana)
#long_test_2     <- long_test_order[-c(198:264,349:396),]
#long_test_2$TRATAMIENTO <- as.factor(long_test_2$TRATAMIENTO)

# Genero un modelo con la variable semana como 칰nica explicatoria:
m0 <- gls(rta ~ SEMANA, correlation=corCAR1(form=~1|ID), data=long_testeo)
Anova(m0)
# Semana explica una parte significativa de la variabilidad de la extensi칩n de prob칩scide en el testeo.

################################################################################
############################### MODELADO #######################################
################################################################################

################## PRIMERA PROPUESTA: MODELO MARGINAL (GEEGLM)

# Modelo:

# Para geeglm, las filas del data frame tienen que estar ordenadas por paciente y por tiempo:
long_testeo <- arrange(long_testeo,ID)

# Notacion de matrices de covarianza en geeglm:
# Estructura simple: independence
# Simetria compuesta: exchangeable
# AR1: ar1
# Desestructurada: unstructured

### A) triple interaccion
m1 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="independence")
anova(m1)
m2 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="exchangeable")
anova(m2)
m3 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="ar1")
anova(m3)
m4 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="unstructured")
anova(m4)

### B) tratamiento*tiempo
m5 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="independence")
anova(m5)
m6 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="exchangeable")
anova(m6)
m7 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="ar1")
anova(m7)
m8 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="unstructured")
anova(m8)

## SELECCION DE MODELOS (en geeglm rankeamos por QIC):
model.sel(m1,m2,m3,m4,m5,m6,m7,m8, rank = QIC)

# Estructura simple: la sacamos porque no estariamos declarando dependencia de datos entre tiempos para una misma abeja.
# Simetria compuesta: decimos que para cada abeja hay una misma correlacion entre tiempos.
# AR1: la sacamos porque a pesar de tener la misma cantidad de par치metros que la de simetria compuesta, tiene un peor ajuste porque nuestros tiempos no son equidistantes como asume AR1, entonces el QIC es mayor.
# Desestructurada: la sacamos porque estima mas parametros, por eso el QIC da un poco mas alto.


################## SEGUNDA PROPUESTA: MODELO CONDICIONAL (GLMMTMB)

# Como elegimos simetria compuesta, probamos un modelo condicional:

# Modelo: 

# glmmTMB es bueno para mixtos y muchos niveles del aleatorio.
m9 <- glmmTMB(rta ~ TRATAMIENTO*tiempo_testeo + SEMANA + (1|ID), data=long_testeo, family="binomial")

################################################################################
########################### EVALUACI칍N DE SUPUESTOS ############################
################################################################################

## Parte fija:
library(DHARMa)
sim <- simulateResiduals(m9, n=1000)
plot(sim)

## Parte aleatoria:
e_aleat<-ranef(m9)%>%as.data.frame()%>%select(4:5)%>%`colnames<-`(c("ID","betai"))
# QQPlot con estos residuos:
qqPlot(e_aleat$betai,main="QQ Plot residuos VE aleatoria")
# Prueba de shapiro:
shapiro.test(e_aleat$betai)

# NO HAY EVIDENCIAS PARA RECHAZAR SUPUESTOS DE LA PARTE FIJA NI ALEATORIA.

################################################################################
########################## ESTIMACI칍N E INFERENCIA #############################
################################################################################

Anova(m9) # Semana e interaccion significativas
summary(m9)

################################################################################
############################### COMPARACIONES ##################################
################################################################################

##### PRIMERA PROPUESTA: COMO TENEMOS COMPARACIONES A PRIORI, HACEMOS BONFERRONI. BONFERRONI SE PUEDE PONER EN EL EMMEANS. 

# Seteamos el emmeans:
options(emmeans= list(emmeans = list(infer = c(TRUE, TRUE)),
                      contrast = list(infer = c(TRUE, TRUE))))

FUNCIONA<-contrast(emmeans(m9,~TRATAMIENTO*tiempo_testeo),type="response",
                list("3hs_alto_pos"=c(1,0,0,-1,0,0,0,0,0,0,0,0), 
                     "3hs_bajo_neg"=c(0,1,-1,0,0,0,0,0,0,0,0,0), 
                     "24hs_alto_pos"=c(0,0,0,0,1,0,0,-1,0,0,0,0), 
                     "24hs_bajo_neg"=c(0,0,0,0,0,1,-1,0,0,0,0,0), 
                     "48hs_alto_pos"=c(0,0,0,0,0,0,0,0,1,0,0,-1), 
                     "48hs_bajo_neg"=c(0,0,0,0,0,0,0,0,0,1,-1,0)),
                adjust="bonferroni")
FUNCIONA
plot(FUNCIONA)  ## Funciona... Mas o menos. Hay que verlo en el TP!

# Esta es una forma m치s linda de escribirlo. Nos da la probabilidad para cada grupo y las comparaciones porque lo seteamos en options m치s arriba en el c칩digo. Podemos graficar los IC y las flechas rojas para comparar.
FUNCIONA2<-emmeans(m9,~TRATAMIENTO*tiempo_testeo,type="response",
                contr=list("3hs_alto_pos"=c(1,0,0,-1,0,0,0,0,0,0,0,0), 
                     "3hs_bajo_neg"=c(0,1,-1,0,0,0,0,0,0,0,0,0), 
                     "24hs_alto_pos"=c(0,0,0,0,1,0,0,-1,0,0,0,0), 
                     "24hs_bajo_neg"=c(0,0,0,0,0,1,-1,0,0,0,0,0), 
                     "48hs_alto_pos"=c(0,0,0,0,0,0,0,0,1,0,0,-1), 
                     "48hs_bajo_neg"=c(0,0,0,0,0,0,0,0,0,1,-1,0)),
                adjust="bonferroni")
FUNCIONA2
plot(FUNCIONA2, comparisons=T) # No sabemos si est치 comaprando bien porque el gr치fico no est치 dividido en las 6 comparaciones.
# Hicimos las comparaciones a mano y las cuentas est치n bien.

################################################################################
############################### GR츼FICO FINAL ##################################
################################################################################


################################################################################
########################### VALIDACI칍N DEL MODELO ##############################
################################################################################

```

