---
title: "Trabajo Práctico Final  \nBiometría II - 2021"
author: "Matías Alemán, Milagros Azcueta, Manuel Fiz, Emilia Haberfeld, Diego Kafer, Ilan Shalom"
date: "21/10/2021"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


# Introducción
Breve y con el único fin de dar el contexto necesario para entender el análisis) y objetivos

# Materiales y métodos
Mencionar, además del diseño experimental o de campo, el o los modelos estadísticos propuestos y la estrategia analítica.

# Resultados
Presentar gráficos y/o Tablas. Editar lo que sea necesario de formato para que el lector comprenda. Informar medias, magnitud del efecto, letras de significación cuando corresponda. Supuestos: salvo excepciones, sólo mencionarlos y mencionar su cumplimiento. Incluir decisiones metodológicas.

# Discusión o conclusión
Párrafo de discusión/conclusión.

# Bibliografía
Si corresponde

```{r}
#################################### SCRIPT ####################################

# Borrar objetos de la memoria
rm(list = ls()) 

################################################################################
####################### CARGA DE LIBRERIAS Y DATOS: ############################
################################################################################

library(reshape2)  #melt
library(pastecs)   #tapply
library(ggplot2)
library(ggeffects) #ggpredict
library(plyr)      #revalue
library(readxl)    #excel
library(nlme)      #gls
library(lmerTest)  #ranova
library(dplyr)
library(geepack)   #geeglm
library(emmeans)   #comparaciones
#install.packages("glmmTMB")
library(glmmTMB)
library(lme4)
#install.packages("car")
library(car)       #Anova
library(MuMIn)     #model.sel
library(dplyr)

setwd("D:/Milagros Azcueta/Documents/GitHub/TP-FINAL-BIOME")
datos <- read_excel("datos.xlsx")
str(datos)
datos$SEMANA         <- as.factor(datos$SEMANA)
datos$ID             <- as.factor(datos$ID)
datos$ANT            <- as.factor(datos$ANT)
datos$PROB           <- as.factor(datos$PROB)
datos$TRATAMIENTO    <- as.factor(datos$TRATAMIENTO)
str(datos)
# Colmena no la vamos a incluir en el analisis porque esta explicada por Semana.

################################################################################
############################### DESCRIPTIVA ####################################
################################################################################

################## ENTRENAMIENTO:

# PASAMOS DATOS ENTRENAMIENTO A LONG:
wide_entr <- datos[,c(1,2,3,4,5,6,7,8,9)]
long_entr <- melt(wide_entr,
                id.vars = c("SEMANA", "ID", "ANT", "PROB", "TRATAMIENTO"),
                variable.name = "tiempo_entr",
                value.name = "rta")

# PROBABILIDAD DE EXITO SEGUN TRATAMIENTO Y TIEMPO:
prob_exito_entr <- round(tapply(long_entr$rta,list(long_entr$TRATAMIENTO,long_entr$tiempo_entr),mean),2)
prob_exito_entr
# Creamos un data frame en formato long con estos valores:
prob_exito_entr_long <- as.data.frame.table(prob_exito_entr)
colnames(prob_exito_entr_long) <- c("TRATAMIENTO","nro_ensayo","proporcion_exitos")

# Graficamente:
gp_entr <- ggplot(prob_exito_entr_long, aes(x=nro_ensayo, y=proporcion_exitos, 
                                        colour=TRATAMIENTO, group=TRATAMIENTO)) +
  geom_line(aes(linetype=TRATAMIENTO), size=.6) +
  geom_point(aes(shape=TRATAMIENTO),size=3) +
  labs(x="Número de ensayo",y="Proporción de éxitos",title="Curva de aprendizaje") +
  ylim(0,1) + theme_bw()
gp_entr


################## TESTEO:

# PASAMOS DATOS TEST A LONG:
wide_testeo <- datos[,c(1,2,3,4,5,10,11,12)]
long_testeo <- melt(wide_testeo,
                  id.vars = c("SEMANA", "ID", "ANT", "PROB", "TRATAMIENTO"),
                  variable.name = "tiempo_testeo",
                  value.name = "rta")

# PROBABILIDAD DE EXITO SEGUN TRATAMIENTO Y TIEMPO EN TESTEO:
prob_exito_testeo <- round(tapply(long_testeo$rta,list(long_testeo$TRATAMIENTO,long_testeo$tiempo_testeo), mean),2)
prob_exito_testeo
# Creamos un data frame en formato long con estos valores:
prob_exito_testeo_long <- as.data.frame.table(prob_exito_testeo)
colnames(prob_exito_testeo_long) <- c("TRATAMIENTO","tiempo_testeo","proporcion_exitos")
# Graficamente:
gp_testeo <- ggplot(prob_exito_testeo_long, aes(x=tiempo_testeo, y=proporcion_exitos,
                                              colour=TRATAMIENTO, group=TRATAMIENTO)) + 
  geom_line(aes(linetype=TRATAMIENTO), size=.6) +
  geom_point(aes(shape=TRATAMIENTO),size=3) +
  labs(x="Tiempo de testeo",y="Proporcion de exitos",
       title="Proporcion de éxitos en función del tiempo y el tratamiento") +
  ylim(0,1) + theme_bw()
gp_testeo


################## SEMANA COMO COVARIABLE:

prob_exito_semana <- round(tapply(long_testeo$rta,list(long_testeo$SEMANA,long_testeo$tiempo_testeo), mean),2)
prob_exito_semana
# Creamos un data frame en formato long con estos valores:
prob_exito_semana_long <- as.data.frame.table(prob_exito_semana)
colnames(prob_exito_semana_long) <- c("SEMANA","tiempo_testeo","proporcion_exitos")

# Graficamente:
gp_semana <- ggplot(prob_exito_semana_long, aes(x=tiempo_testeo, y=proporcion_exitos, colour=SEMANA,group=SEMANA)) +
  geom_line(aes(linetype=SEMANA), size=.6) +
  geom_point(aes(shape=SEMANA),size=3) +
  labs(x="Tiempo de testeo",y="Proporción de éxitos",title="Proporcion de éxitos en función del tiempo y la semana") +
  ylim(0,1) + theme_bw()
gp_semana

## Las semanas 5 y 7 parecen ser outliers. Podria excluirlas:
######## LO DEJO COMENTADO PERO LA IDEA ES NO SACAR LOS DATOS.
# Primero ordeno el df por semana para ver que filas quiero sacar. Despues las borro.
#long_test_order <- arrange(long_test,Semana)
#long_test_2     <- long_test_order[-c(198:264,349:396),]
#long_test_2$TRATAMIENTO <- as.factor(long_test_2$TRATAMIENTO)

# Genero un modelo con la variable semana como única explicatoria:
m0 <- gls(rta ~ SEMANA, correlation=corCAR1(form=~1|ID), data=long_testeo)
Anova(m0)
# Semana explica una parte significativa de la variabilidad de la extensión de probóscide en el testeo.

################################################################################
############################### MODELADO #######################################
################################################################################

################## PRIMERA PROPUESTA: MODELO MARGINAL (GEEGLM)

# Modelo:

# Para geeglm, las filas del data frame tienen que estar ordenadas por paciente y por tiempo:
long_testeo <- arrange(long_testeo,ID)

# Notacion de matrices de covarianza en geeglm:
# Estructura simple: independence
# Simetria compuesta: exchangeable
# AR1: ar1
# Desestructurada: unstructured

### A) triple interaccion
m1 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="independence")
anova(m1)
m2 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="exchangeable")
anova(m2)
m3 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="ar1")
anova(m3)
m4 <- geeglm(formula=rta~ANT*PROB*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="unstructured")
anova(m4)

### B) tratamiento*tiempo
m5 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="independence")
anova(m5)
m6 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="exchangeable")
anova(m6)
m7 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="ar1")
anova(m7)
m8 <- geeglm(formula=rta~TRATAMIENTO*tiempo_testeo+SEMANA,family=binomial,data=long_testeo,id=ID,
             corstr="unstructured")
anova(m8)

## SELECCION DE MODELOS (en geeglm rankeamos por QIC):
model.sel(m1,m2,m3,m4,m5,m6,m7,m8, rank = QIC)

# Estructura simple: la sacamos porque no estariamos declarando dependencia de datos entre tiempos para una misma abeja.
# Simetria compuesta: decimos que para cada abeja hay una misma correlacion entre tiempos.
# AR1: la sacamos porque a pesar de tener la misma cantidad de parámetros que la de simetria compuesta, tiene un peor ajuste porque nuestros tiempos no son equidistantes como asume AR1, entonces el QIC es mayor.
# Desestructurada: la sacamos porque estima mas parametros, por eso el QIC da un poco mas alto.


################## SEGUNDA PROPUESTA: MODELO CONDICIONAL (GLMMTMB)

# Como elegimos simetria compuesta, probamos un modelo condicional:

# Modelo: 

# glmmTMB es bueno para mixtos y muchos niveles del aleatorio.
m9 <- glmmTMB(rta ~ TRATAMIENTO*tiempo_testeo + SEMANA + (1|ID), data=long_testeo, family="binomial")

################################################################################
########################### EVALUACIÓN DE SUPUESTOS ############################
################################################################################

## Parte fija:
library(DHARMa)
sim <- simulateResiduals(m9, n=1000)
plot(sim)

## Parte aleatoria:
e_aleat<-ranef(m9)%>%as.data.frame()%>%select(4:5)%>%`colnames<-`(c("ID","betai"))
# QQPlot con estos residuos:
qqPlot(e_aleat$betai,main="QQ Plot residuos VE aleatoria")
# Prueba de shapiro:
shapiro.test(e_aleat$betai)

# NO HAY EVIDENCIAS PARA RECHAZAR SUPUESTOS DE LA PARTE FIJA NI ALEATORIA.

################################################################################
########################## ESTIMACIÓN E INFERENCIA #############################
################################################################################

Anova(m9) # Semana e interaccion significativas
summary(m9)

################################################################################
############################### COMPARACIONES ##################################
################################################################################

##### PRIMERA PROPUESTA: COMO TENEMOS COMPARACIONES A PRIORI, HACEMOS BONFERRONI. BONFERRONI SE PUEDE PONER EN EL EMMEANS. 

# Seteamos el emmeans:
options(emmeans= list(emmeans = list(infer = c(TRUE, TRUE)),
                      contrast = list(infer = c(TRUE, TRUE))))

FUNCIONA<-contrast(emmeans(m9,~TRATAMIENTO*tiempo_testeo),type="response",
                list("3hs_alto_pos"=c(1,0,0,-1,0,0,0,0,0,0,0,0), 
                     "3hs_bajo_neg"=c(0,1,-1,0,0,0,0,0,0,0,0,0), 
                     "24hs_alto_pos"=c(0,0,0,0,1,0,0,-1,0,0,0,0), 
                     "24hs_bajo_neg"=c(0,0,0,0,0,1,-1,0,0,0,0,0), 
                     "48hs_alto_pos"=c(0,0,0,0,0,0,0,0,1,0,0,-1), 
                     "48hs_bajo_neg"=c(0,0,0,0,0,0,0,0,0,1,-1,0)),
                adjust="bonferroni")
FUNCIONA
plot(FUNCIONA)  ## Funciona... Mas o menos. Hay que verlo en el TP!

# Esta es una forma más linda de escribirlo. Nos da la probabilidad para cada grupo y las comparaciones porque lo seteamos en options más arriba en el código. Podemos graficar los IC y las flechas rojas para comparar.
FUNCIONA2<-emmeans(m9,~TRATAMIENTO*tiempo_testeo,type="response",
                contr=list("3hs_alto_pos"=c(1,0,0,-1,0,0,0,0,0,0,0,0), 
                     "3hs_bajo_neg"=c(0,1,-1,0,0,0,0,0,0,0,0,0), 
                     "24hs_alto_pos"=c(0,0,0,0,1,0,0,-1,0,0,0,0), 
                     "24hs_bajo_neg"=c(0,0,0,0,0,1,-1,0,0,0,0,0), 
                     "48hs_alto_pos"=c(0,0,0,0,0,0,0,0,1,0,0,-1), 
                     "48hs_bajo_neg"=c(0,0,0,0,0,0,0,0,0,1,-1,0)),
                adjust="bonferroni")
FUNCIONA2
plot(FUNCIONA2, comparisons=T) # No sabemos si está comaprando bien porque el gráfico no está dividido en las 6 comparaciones.
# Hicimos las comparaciones a mano y las cuentas están bien.

################################################################################
############################### GRÁFICO FINAL ##################################
################################################################################


################################################################################
########################### VALIDACIÓN DEL MODELO ##############################
################################################################################

```

